# Concepts

## Cross Chain Fees

Because sifchain will allow users to transfer assets from sifchain to other EVM chains (Ethereum, Binance Smart Chain, Polygon, etc.), sifchain will incur gas costs on those other chains for the transaction.
These gas costs can become a severe source of attack if sifchain just absorbed them, and so a mechanism was constructed to charge users in the native currency of the chain they are exporting to a cross-chain fee to cover the gas costs. This mechanism in Peggy 2.0 is straightforward as it consists of a constant value set per network ID of how much of the native currency of that chain must be charged for a
user to export assets over. A secondary cross-chain fee is established for Peggy 2.0, which covers new bridge token construction for first-time exporters of an asset to a new EVM chain. If a user exports
either an IBC asset or a double pegged asset (non-native EVM asset) to an EVM chain that has not been exported before, a bridge token has to be deployed for those tokens, and a higher cross-chain fee has to
be billed for the gas cost of deploying that contract. This secondary fee is necessary as Peggy 2.0 does not have an EVM whitelist, so users could deploy tons of ERC20 tokens on polygon for
cheap and then use sifchain to export those ERC20 tokens onto Ethereum where gas is expensive. This attack is mitigated by charging a high cross-chain fee for first-time exports.

## Virtual Mempool

Peggy 2.0 introduces the concept of signature aggregation, which allows us to reduce the number of transactions to an EVM chain from four transactions per transfer across the bridge to one. This will significantly reduce
gas costs for transferring assets across the bridge to more expensive chains such as Ethereum. The mechanism for signature aggregation is coordinated through the concept of a virtual mempool. Witnesses are middleware that
monitor the Sifchain blockchain for log events regarding transactions; when it sees either an EventTypeLock or EventTypeBurn the Witness constructs a prophecy and signs the prophecy with its EVM private key. The Witness
then submits the signed prophecy for the sequence number of that transaction into the virtual mempool which is a standard cosmos keeper. The relayer watches the virtual
mempool. When it observes enough witnesses have submitted prophecies for a transaction to complete, it will then relay the prophecy with the aggregated signatures of those witnesses to the BridgeBank of the EVM chain
for this transaction. After about a month (based upon block height), the prophecies are cleared from the cosmos keeper.

## Token Denom Hashing for EVM-native assets

To uniquely identify EVM-native assets such as the native currency or ERC20 tokens, we internally use a denom for
the relayers and sifnode banking modules. The EVM Native denom is a formatted string generated by concatenating `sifBridge`
followed by the originating internal EVM network descriptor as a base 10 number consisting of 4 characters (0000~9999), followed by
the ERC20 token address or the null token address for EVM native assets with
all characters lower case and the 0x included (0x0000000000000000000000000000000000000000). `sifBridge{evmChainId}{tokenAddress}`.

### Example 1

We want to calculate denom hash of Ethereum native currency, Ether.

1. We take the network descriptor of '1', which is formatted as `0001`
2. We take contract address of '0x0000000000000000000000000000000000000000'
3. We concatenate the string with the prefix to get:
   ```
   sifBridge00010x0000000000000000000000000000000000000000
   ```

### Example 2

We want to calculate denom hash of an ERC20 token 'JimmyToken' on an EVM network.

1. We take network descriptor of '20', which is formatted as `0020`
2. We take the EVM address of deployed token's smart contract, e.g. '0xbF45BFc92ebD305d4C0baf8395c4299bdFCE9EA2' (in lowercase)
3. We concatenate the string with the prefix to get:
   ```
   sifBridge00200xbf45bfc92ebd305d4c0baf8395c4299bdfce9ea2
   ```

## OFAC Blocklist
In order to comply with OFAC sanctions and to prevent Sifchain's DEX from being used for illegal purposes, Sifchain has deployed a separate contract called the Blocklist, this contract contains an array, and mapping of OFAC sanctioned EVM addresses which our smart contracts will query before processing a request. By storing each blocked address in both a mapping and an array we are able to quickly search if any address is currently blocked in O(1) time while also being able to query the entire set of blocked addresses for comparison during updates. If any request comes in from a prohibited address, the smart contracts will automatically reject the transaction. Every 24 hours, Sifchain runs a script against the OFAC website listing sanctioned addresses, extracts the EVM addresses from the document, queries all the addresses in the smart contract and then removes any addresses removed from the OFAC list and adds any new addresses not currently in the list to the list. This process is done in five parts:
 1. The script calls getFullList, which returns an array of all addresses currently blocked by the blocklist
 2. The script queries the OFAC website and extracts all valid EVM addresses
 3. The script identifies any addresses that are currently being blocked that are not on the OFAC blocklist and identifies any addresses that are not on the blocklist that are currently on the OFAC website
 4. The script calls removeFromBlocklist or batchRemoveFromBlocklist with the list of addresses that need to be removed from the blocklist
 5. The script calls addToBlocklist or batchAddtoBlocklist with the list of addresses that need to be added to the blocklist