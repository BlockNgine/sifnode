# Concepts

## Cross Chain Fees

Because sifchain will allow users to transfer assets from sifchain to other EVM chains (Ethereum, Binance Smart Chain, Polygon, etc.), sifchain will incur gas costs on those other chains for the transaction.
These gas costs can become a severe source of attack if sifchain just absorbed them, and so a mechanism was constructed to charge users in the native currency of the chain they are exporting to a cross-chain fee to cover the gas costs. This mechanism in Peggy 2.0 is straightforward as it consists of a constant value set per network ID of how much of the native currency of that chain must be charged for a
user to export assets over. A secondary cross-chain fee is established for Peggy 2.0, which covers new bridge token construction for first-time exporters of an asset to a new EVM chain. If a user exports
either an IBC asset or a double pegged asset (non-native EVM asset) to an EVM chain that has not been exported before, a bridge token has to be deployed for those tokens, and a higher cross-chain fee has to
be billed for the gas cost of deploying that contract. This secondary fee is necessary as Peggy 2.0 does not have an EVM whitelist, so users could deploy tons of ERC20 tokens on polygon for
cheap and then use sifchain to export those ERC20 tokens onto Ethereum where gas is expensive. This attack is mitigated by charging a high cross-chain fee for first-time exports.

## Virtual Mempool

Peggy 2.0 introduces the concept of signature aggregation, which allows us to reduce the number of transactions to an EVM chain from four transactions per transfer across the bridge to one. This will significantly reduce
gas costs for transferring assets across the bridge to more expensive chains such as Ethereum. The mechanism for signature aggregation is coordinated through the concept of a virtual mempool. Witnesses are middleware that
monitor the Sifchain blockchain for log events regarding transactions; when it sees either an EventTypeLock or EventTypeBurn the Witness constructs a prophecy and signs the prophecy with its EVM private key. The Witness
then submits the signed prophecy for the sequence number of that transaction into the virtual mempool which is a standard cosmos keeper. The relayer watches the virtual
mempool. When it observes enough witnesses have submitted prophecies for a transaction to complete, it will then relay the prophecy with the aggregated signatures of those witnesses to the BridgeBank of the EVM chain
for this transaction. After about a month (based upon block height), the prophecies are cleared from the cosmos keeper.

## Token Denom Hashing for EVM-native assets

To uniquely identify EVM-native assets such as the native currency or ERC20 tokens, we internally use a denom for
the relayers and sifnode banking modules. The EVM Native denom is a formatted string generated by concatenating `sifBridge`
followed by the originating internal EVM network descriptor as a base 10 number consisting of 4 characters (0000~9999), followed by
the ERC20 token address or the null token address for EVM native assets with
all characters lower case and the 0x included (0x0000000000000000000000000000000000000000). `sifBridge{evmChainId}{tokenAddress}`.

### Example 1

We want to calculate denom hash of Ethereum native currency, Ether.

1. We take the network descriptor of '1', which is formatted as `0001`
2. We take contract address of '0x0000000000000000000000000000000000000000'
3. We concatenate the string with the prefix to get:
   ```
   sifBridge00010x0000000000000000000000000000000000000000
   ```

### Example 2

We want to calculate denom hash of an ERC20 token 'JimmyToken' on an EVM network.

1. We take network descriptor of '20', which is formatted as `0020`
2. We take the EVM address of deployed token's smart contract, e.g. '0xbF45BFc92ebD305d4C0baf8395c4299bdFCE9EA2' (in lowercase)
3. We concatenate the string with the prefix to get:
   ```
   sifBridge00200xbf45bfc92ebd305d4c0baf8395c4299bdfce9ea2
   ```
